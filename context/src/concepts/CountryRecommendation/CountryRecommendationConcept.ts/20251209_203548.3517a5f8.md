---
timestamp: 'Tue Dec 09 2025 20:35:48 GMT-0500 (Eastern Standard Time)'
content_id: 3517a5f85f1cf3a3c8247375b16bfdeb0755249d56b2f011f1c25ac2e5e9cd5a
---

# file: src/concepts/CountryRecommendation/CountryRecommendationConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";
import { GeminiLLM } from "../../../gemini-llm.ts";
import axios from "npm:axios";
import { COUNTRY_CODE_MAP } from "./COUNTRY_CODE_MAP.ts";

interface SpotifyTrack {
  id: string;
  name: string;
  artists: Array<{ name: string }>;
  external_urls: {
    spotify: string;
  };
}

// Declare collection prefix, use concept name
const PREFIX = "CountryRecommendation" + ".";

// Declare amount of recommendations to query for get calls, default 3
export const QUERY_QUANTITY = 3;

// Multiplier to request more recommendations if number of stored recommendations is less than (QUERY_QUANTITY * MULTIPLIER), default 5 for prod
export const BASELINE_MULTIPLIER = 3;

// Scale for deciding LLM call probability (control how quickly the probability decays as database grows)
const LLM_CALL_SCALE = 20;

// Internal entity types, represented as IDs
type recId = ID;

interface Country {
  _id: string;
  recommendations: recId[];
}

interface RecommendationEntry {
  _id: recId;
  countryName: string;
  songTitle: string;
  artist: string;
  language: string;
  youtubeURL: string;
  recType: "SYSTEM" | "COMMUNITY";
  genre: string;
}

/**
 * @concept CountryRecommendation
 * @purpose provide Users with song recommendations from a specific country.
 * @principle maintain, update, and deliver curated (system) and user-added (community) song recommendations for each country, fetching new recommendations from an LLM when needed.
 */
export default class CountryRecommendationConcept {
  private readonly countryCollection: Collection<Country>;
  private readonly recommendationCollection: Collection<RecommendationEntry>;

  constructor(private readonly db: Db) {
    this.countryCollection = this.db.collection(PREFIX + "countries");
    this.recommendationCollection = this.db.collection(
      PREFIX + "recommendations",
    );
  }

  /**
   * @effects if countryName doesn't already exist, create new Country with empty recs
   */
  private async getCountryEntry(
    { countryName }: { countryName: string },
  ): Promise<{ country: Country } | { error: string }> {
    const existing = await this.countryCollection.findOne({ _id: countryName });
    if (existing) {
      return { country: existing };
    }

    try {
      await this.countryCollection.insertOne({
        _id: countryName,
        recommendations: [],
      });

      console.log(
        `CREATED new entry for country: ${countryName}`,
      );
    } catch (error: any) {
      // Handle duplicate key error (race condition - another request created it first)
      if (error.code === 11000) {
        console.log(
          `Country ${countryName} already exists (race condition), fetching existing entry`,
        );
      } else {
        // Re-throw if it's not a duplicate key error
        throw error;
      }
    }

    // Fetch the country entry (whether we just created it or it already existed)
    const newCountry = await this.countryCollection.findOne({
      _id: countryName,
    });
    if (!newCountry) return { error: "Failed to create or fetch country." };

    return { country: newCountry };
  }

  /**
   * @requires countryName exists
   * @effects call LLM for new song recommendations from countryName and create new recommendation entries
   * @returns list of recIds
   */
  private async getNewRecs(
    { countryName }: { countryName: string },
  ): Promise<{ recommendations: RecommendationEntry[] } | { error: string }> {
    let allVerifiedRecs: RecommendationEntry[] = [];
    let retries = 0;
    const maxRetries = 2;

    while (allVerifiedRecs.length < QUERY_QUANTITY && retries < maxRetries) {
      // STEP 1: Get artists from LLM (array of artist names)
      const jsonResponse = await this.llmFetch(countryName, QUERY_QUANTITY);

      const jsonStart = jsonResponse.indexOf("[");
      const jsonEnd = jsonResponse.lastIndexOf("]") + 1;

      if (jsonStart === -1 || jsonEnd === -1) {
        return {
          error:
            "LLM response parsing error: JSON array not found in response.",
        };
      }

      const jsonString = jsonResponse.substring(jsonStart, jsonEnd);

      let artists: string[];

      try {
        const parsed = JSON.parse(jsonString);
        // Handle both string array and object array formats
        if (Array.isArray(parsed)) {
          if (parsed.length > 0 && typeof parsed[0] === "string") {
            artists = parsed;
          } else if (
            parsed.length > 0 && typeof parsed[0] === "object" &&
            "artist" in parsed[0]
          ) {
            artists = (parsed as Array<{ artist: string }>).map((item) =>
              item.artist
            );
          } else {
            return { error: "LLM returned unexpected artist format" };
          }
        } else {
          return { error: "LLM response is not an array" };
        }
      } catch (_err) {
        return { error: "LLM returned invalid JSON" };
      }

      if (!Array.isArray(artists) || artists.length === 0) {
        return { error: "LLM returned empty or invalid artist list" };
      }

      const newRecs: RecommendationEntry[] = [];

      // STEP 2: For each artist, get a song from discography on Spotify via Spotify API
      for (const artist of artists) {
        const spotifySong = await this.getSpotifySongFromArtist(
          countryName,
          artist,
        );

        if (!spotifySong) {
          console.warn(
            `Could not find valid song from artist ${artist}, skipping...`,
          );
          continue;
        }

        // STEP 3: Get YouTube URL for the song via youtube API
        const spotifyArtistName = spotifySong.artists[0]?.name || artist;
        const youtubeAPIUrl = await this.getYoutubeUrl(
          spotifySong.name,
          spotifyArtistName,
        );

        const newRec: RecommendationEntry = {
          _id: freshID() as recId,
          countryName: countryName,
          songTitle: spotifySong.name,
          artist: spotifyArtistName,
          language: "",
          youtubeURL: youtubeAPIUrl,
          recType: "SYSTEM",
          genre: "", // TODO: fetch genre
        };

        newRecs.push(newRec);
      }

      // STEP 4: Verify songs via LLM and get song language
      const verifiedRecs = await this.verifyAndFilterSongs(
        countryName,
        newRecs,
      );

      // Add verified songs to the accumulator
      allVerifiedRecs = allVerifiedRecs.concat(verifiedRecs);

      if (allVerifiedRecs.length < QUERY_QUANTITY) {
        retries++;
        if (retries < maxRetries) {
          console.log(
            `‚ö†Ô∏è Only ${allVerifiedRecs.length} verified songs found (need ${QUERY_QUANTITY}). Retrying... (Attempt ${
              retries + 1
            }/${maxRetries})`,
          );
        }
      }
    }

    // Log final count
    console.log(
      `‚úÖ Got ${allVerifiedRecs.length} verified songs after ${retries} retry attempt(s)`,
    );

    // Take only the first QUERY_QUANTITY songs
    const selectedRecs = allVerifiedRecs.slice(0, QUERY_QUANTITY);

    // Check for duplicates before inserting
    const finalRecs: RecommendationEntry[] = [];

    for (const rec of selectedRecs) {
      const existing = await this.recommendationCollection.findOne({
        country: countryName,
        songTitle: rec.songTitle,
        artist: rec.artist,
      });

      if (existing) {
        // is a duplicate, use the existing one in database
        finalRecs.push(existing);
      } else {
        // Not a duplicate ‚Üí insert the new one
        await this.recommendationCollection.insertOne(rec);

        // Add its ID to the country doc
        await this.countryCollection.updateOne(
          { _id: countryName },
          { $push: { recommendations: rec._id } },
        );

        finalRecs.push(rec);
      }
    }

    return { recommendations: finalRecs };
  }

  /**
   * Helper to verify songs via LLM and filter out unverified ones
   * @returns array of verified recommendations with language populated
   */
  private async verifyAndFilterSongs(
    countryName: string,
    recommendations: RecommendationEntry[],
  ): Promise<RecommendationEntry[]> {
    const songsToVerify = recommendations.map((rec) => ({
      title: rec.songTitle,
      artist: rec.artist,
      youtubeURL: rec.youtubeURL,
    }));

    const verificationResponse = await this.llmVerify(
      countryName,
      songsToVerify,
    );

    // Parse the verification response
    const verifyJsonStart = verificationResponse.indexOf("[");
    const verifyJsonEnd = verificationResponse.lastIndexOf("]") + 1;

    if (verifyJsonStart === -1 || verifyJsonEnd === -1) {
      console.warn(
        "LLM verification response parsing error, proceeding without verification",
      );
      return recommendations; // Return all recommendations if parsing fails
    }

    const verifiedRecs: RecommendationEntry[] = [];

    try {
      const verifyJsonString = verificationResponse.substring(
        verifyJsonStart,
        verifyJsonEnd,
      );
      const llmVerificationJSON = JSON.parse(verifyJsonString) as Array<{
        songTitle: string;
        artist: string;
        youtubeURL: string;
        verified: string | boolean;
        language: string;
      }>;

      // Update recommendations with verified language data and filter out unverified songs
      for (
        let i = 0;
        i < recommendations.length && i < llmVerificationJSON.length;
        i++
      ) {
        const verifiedSong = llmVerificationJSON[i];
        // Handle both boolean true and string "true"
        const isVerified = verifiedSong.verified === true ||
          verifiedSong.verified === "true";
        if (isVerified && verifiedSong.language) {
          recommendations[i].language = verifiedSong.language;
          verifiedRecs.push(recommendations[i]);
          console.log(
            `‚úÖ VERIFIED: "${recommendations[i].songTitle}" by ${
              recommendations[i].artist
            } - Language: ${verifiedSong.language}`,
          );
        } else {
          console.warn(
            `‚ö†Ô∏è FAILED verification: "${recommendations[i].songTitle}" by ${
              recommendations[i].artist
            }"`,
          );
        }
      }
    } catch (_err) {
      console.warn(
        "Failed to parse LLM verification response, proceeding without verification",
      );
      return recommendations; // Return all recommendations if parsing fails
    }

    return verifiedRecs;
  }

  /**
   * Helper to execute LLM request to fetch artists
   */
  private async llmFetch(
    countryName: string,
    amount: number,
  ): Promise<string> {
    const llm = this.loadLLM();
    const prompt = this.getArtistPrompt(countryName, amount, "");
    // console.log(prompt);

    try {
      console.log(
        `ü§ñ Requesting artists in ${countryName} from Gemini AI...`,
      );
      const response = await llm.executeLLM(prompt);

      console.log("‚úÖ Received response from Gemini AI!");
      console.log("\nü§ñ RAW GEMINI RESPONSE");
      console.log("======================");
      console.log(response);
      console.log("======================\n");

      return response;
    } catch (error) {
      // Non-retryable errors propagate immediately
      console.error("‚ùå Unexpected error:", (error as Error).message);
      throw error;
    }
  }

  /**
   * Helper to verify songs and get language via LLM
   */
  private async llmVerify(
    countryName: string,
    songs: Array<{ title: string; artist: string; youtubeURL: string }>,
  ): Promise<string> {
    const llm = this.loadLLM();
    const prompt = this.getVerifyPrompt(countryName, songs);
    // console.log(prompt);

    try {
      console.log(
        `ü§ñ Verifying songs via Gemini AI...`,
      );
      const response = await llm.executeLLM(prompt);

      console.log("‚úÖ Received response from Gemini AI!");
      console.log("\nü§ñ RAW GEMINI RESPONSE");
      console.log("======================");
      console.log(response);
      console.log("======================\n");

      return response;
    } catch (error) {
      // Non-retryable errors propagate immediately
      console.error("‚ùå Unexpected error:", (error as Error).message);
      throw error;
    }
  }

  private async getYoutubeUrl(title: string, artist: string): Promise<string> {
    const apiKey = Deno.env.get("YOUTUBE_API_KEY");
    if (!apiKey) {
      console.error("YOUTUBE_API_KEY not set in environment variables.");
      return "";
    }

    // const query = encodeURIComponent(`${title} ${artist} official music video`);
    const query = `${title} ${artist} official music video`;

    const url = `https://www.googleapis.com/youtube/v3/search`;

    try {
      const response = await axios.get(url, {
        params: {
          key: apiKey,
          q: query,
          part: "snippet",
          type: "video",
          maxResults: 1,
          videoEmbeddable: "true",
        },
      });

      console.log(
        `YouTube API response for ${title} by ${artist}:`,
        response.data,
      );

      const items = response.data.items;

      if (!items || items.length === 0) {
        console.warn(`No YouTube results found for ${title} by ${artist}.`);
        return "";
      }

      const videoId = items[0].id.videoId;
      return `https://www.youtube.com/watch?v=${videoId}`;
    } catch (error) {
      console.error("Error fetching YouTube URL:", (error as Error).message);
      return "";
    }
  }

  /**
   * Get Spotify access token using Client Credentials flow
   */
  private async getSpotifyAccessToken(): Promise<string | null> {
    const clientId = Deno.env.get("SPOTIFY_CLIENT_ID");
    const clientSecret = Deno.env.get("SPOTIFY_CLIENT_SECRET");

    if (!clientId || !clientSecret) {
      console.error(
        "SPOTIFY_CLIENT_ID or SPOTIFY_CLIENT_SECRET not set in environment variables.",
      );
      return null;
    }

    const auth = btoa(`${clientId}:${clientSecret}`);

    try {
      const response = await axios.post(
        "https://accounts.spotify.com/api/token",
        "grant_type=client_credentials",
        {
          headers: {
            Authorization: `Basic ${auth}`,
            "Content-Type": "application/x-www-form-urlencoded",
          },
        },
      );

      return response.data.access_token;
    } catch (error) {
      console.error(
        "Error getting Spotify access token:",
        (error as Error).message,
      );
      return null;
    }
  }

  /**
   * Get a song from Spotify API by artist name
   * Returns the first available track from the artist
   */
  private async getSpotifySongFromArtist(
    countryName: string,
    artistName: string,
  ): Promise<SpotifyTrack | null> {
    const token = await this.getSpotifyAccessToken();
    if (!token) {
      console.error("Could not obtain Spotify access token.");
      return null;
    }

    // Convert country name to ISO code, default to US if not found
    const marketCode = COUNTRY_CODE_MAP[countryName] || "US";

    try {
      // Search for the artist - try without the strict "artist:" prefix first
      console.log(`Searching Spotify for artist: "${artistName}"...`);
      const searchResponse = await axios.get(
        "https://api.spotify.com/v1/search",
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
          params: {
            q: artistName,
            type: "artist",
            limit: 3,
          },
        },
      );

      const artists = searchResponse.data.artists.items;
      if (!artists || artists.length === 0) {
        console.warn(`Artist "${artistName}" not found on Spotify.`);
        return null;
      }

      // Try to find exact match first, otherwise use first result
      let matchedArtist = artists.find(
        (a: { name: string }) =>
          a.name.toLowerCase() === artistName.toLowerCase(),
      );

      if (!matchedArtist) {
        // If no exact match, use the first result
        matchedArtist = artists[0];
        console.log(
          `No exact match for "${artistName}", using closest match: "${matchedArtist.name}"`,
        );
      }

      const artistId = matchedArtist.id;
      console.log(
        `Found artist "${matchedArtist.name}" on Spotify with ID: ${artistId}`,
      );

      // Get top tracks from the artist
      console.log(
        `Fetching top tracks for artist ID ${artistId} with market: ${marketCode}`,
      );
      const tracksResponse = await axios.get(
        `https://api.spotify.com/v1/artists/${artistId}/top-tracks`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
          params: {
            // market: marketCode,
          },
        },
      );

      const tracks = tracksResponse.data.tracks;
      if (!tracks || tracks.length === 0) {
        console.warn(`No tracks found for artist ${artistName}.`);
        return null;
      }

      // Select a random track instead of the first one
      const randomIndex = Math.floor(Math.random() * tracks.length);
      const track = tracks[randomIndex];
      console.log(
        `Got track "${track.name}" (${
          randomIndex + 1
        }/${tracks.length}) from artist ${artistName} on Spotify`,
      );

      return {
        id: track.id,
        name: track.name,
        artists: track.artists,
        external_urls: track.external_urls,
      };
    } catch (error) {
      const errorMsg = axios.isAxiosError(error)
        ? `Status ${error.response?.status}: ${error.response?.statusText}`
        : (error as Error).message;
      console.error(
        `Error fetching song from Spotify for artist ${artistName}: ${errorMsg}`,
      );
      if (axios.isAxiosError(error) && error.response?.data) {
        console.error("Spotify API response:", error.response.data);
      }
      return null;
    }
  }

  private getArtistPrompt(
    countryName: string,
    amount: number,
    genre: string,
  ): string {
    const criticalRequirements = [
      `1. Artists must originate from the specified country.`,
      `2. Artists must be underground or small (not widely known internationally).`,
      `3. Artists must be on Spotify.`,
    ];

    const suffix = (genre !== "") ? `with the genre ${genre}.` : `.`;

    const prompt =
      `You are a helpful AI assistant in the role of a global music curator who specializes
    in providing artist recommendations from various countries around the world.
    Given a country name, your task is to suggest ${amount} artists that are underground or small music artists originating from that country. Perform the following steps:

    1. Find ${amount} different underground or small music artists in the given country.
    2. You must strictly adhere to the following critical requirements:
      ${criticalRequirements.join("\n")}

    ***VERIFICATION PROCESS (MANDATORY):***
    1. Before including any artist, the model must internally confirm the artist's origin from the specified country.
    3. **If verification fails for an artist, it MUST be discarded, and a new artist must be chosen until ${amount} verified results are found.**

    Your response must be formatted as a array of strings. Each string should be the name of an artist.

    EXAMPLE: An example of a properly formatted response for 3 artists in Taiwan is as follows:
    RESPONSE: [ "LilHAO", "ËåÑÂ≠êËõã EggPlantEgg", "Èô≥ÂøªÁé•" ]

    DO NOT include any additional text, explanations, or commentary outside of the array.

    In other words, your first character must be "[" and your last character must be "]".

    Now, with all this in mind, provide ${amount} underground or small music artists in ${countryName}` +
      suffix;

    return prompt;
  }

  private getVerifyPrompt(
    countryName: string,
    songs: Array<{ title: string; artist: string; youtubeURL: string }>,
  ): string {
    const prompt =
      `Verify that the following songs originate from ${countryName} and provide the language in which the song is sung.

      Your response should be a JSON array of length ${songs.length}. Each object in the array should have the following format:
      {
        "songTitle": "<Title of the song>",
        "artist": "<Name of the artist>",
        "youtubeURL": "<YouTube URL of the song>",
        "verified": "<true if the song is verified to be from ${countryName}, false otherwise>"
        "language": "<Language of the song IF verified is true, empty string otherwise>",
      }
      EXAMPLE RESPONSE for country=Taiwan: [
      [
        {
          "songTitle": "Em Kh√¥ng",
          "artist": "V≈© Thanh V√¢n",
          "youtubeURL": "https://youtu.be/CufIAJDVZvo?si=zcMY21zBouslilhJ",
          "verified": "false",
          "language": ""
        },
        {
          "songTitle": "ËΩü18‰º∂‰ªÉ",
          "artist": "LilHAO",
          "youtubeURL": "https://youtu.be/oLIRyn56kf8?si=xb0phDTAVjeaaPJS",
          "verified": "true",
          "language": "Mandarin"
        },
        {
          "songTitle": "ÈÅãËΩâ‰∫∫Áîü",
          "artist": "ÈÇ±ËªçKui",
          "youtubeURL": "https://www.youtube.com/watch?v=x-OinY-8bxc",
          "verified": "true",
          "language": "Taiwanese Hokkien"
        }
      ]

      SONGS TO VERIFY: ${JSON.stringify(songs)}`;

    return prompt;
  }

  /**
   * @requires countryName exists
   * @effects filter recs of type "SYSTEM" and choose QUERY_QUANTITY recs, sometimes call LLM
   * @returns randomly chosen rec IDs
   */
  async getSystemRecs(
    { countryName }: { countryName: string },
  ): Promise<{ recommendations: RecommendationEntry[] } | { error: string }> {
    const country = await this.getCountryEntry({ countryName });
    if ("error" in country) {
      return { error: country.error };
    }

    try {
      const systemRecs = await this.recommendationCollection.find({
        _id: { $in: country.country.recommendations },
        recType: "SYSTEM",
      })
        .toArray();

      if (systemRecs.length <= QUERY_QUANTITY * BASELINE_MULTIPLIER) {
        // Call LLM to get new recommendations
        console.log(
          `Not enough SYSTEM recommendations for ${countryName} (${systemRecs.length} found). Calling LLM for new recommendations...`,
        );
        return this.getNewRecs({ countryName });
      }

      // Randomize when to pick recommendations from stored recommendations or call LLM
      const p = LLM_CALL_SCALE / (systemRecs.length + LLM_CALL_SCALE);

      if (Math.random() < p) {
        console.log(
          `Decided to call LLM for new recommendations for ${countryName} (p=${
            p.toFixed(3)
          }).`,
        );
        return this.getNewRecs({ countryName });
      } else {
        console.log(
          `Using stored SYSTEM recommendations for ${countryName} (p=${
            p.toFixed(3)
          }).`,
        );
        // Pick QUERY_QUANTITY random recommendations from stored ones
        const shuffled = systemRecs.sort(() => 0.5 - Math.random());
        const selected = shuffled.slice(0, QUERY_QUANTITY);
        return { recommendations: selected };
      }
    } catch (e) {
      return { error: `Error retrieving system recommendations. ERROR: ${e}` };
    }
  }

  /**
   * @requires countryName exists
   * @effects filter recs of type "COMMUNITY" and choose QUERY_QUANTITY recs or all community recs, whichever is smaller
   * @returns randomly chosen rec IDs
   */
  async getCommunityRecs(
    { countryName }: { countryName: string },
  ): Promise<{ recommendations: RecommendationEntry[] } | { error: string }> {
    const country = await this.getCountryEntry({ countryName });
    if ("error" in country) {
      return { error: country.error };
    }

    try {
      console.log(
        `Fetching COMMUNITY recommendations for ${countryName}...`,
      );
      const communityRecs = await this.recommendationCollection.find({
        _id: { $in: country.country.recommendations },
        recType: "COMMUNITY",
      })
        .toArray();

      if (communityRecs.length <= QUERY_QUANTITY) {
        return { recommendations: communityRecs };
      }

      const shuffled = communityRecs.sort(() => 0.5 - Math.random());
      const selected = shuffled.slice(0, QUERY_QUANTITY);
      return { recommendations: selected };
    } catch (e) {
      return {
        error: `Error retrieving community recommendations. ERROR: ${e}`,
      };
    }
  }

  /**
   * @requires countryName exists
   * @effects create new community Recommendation
   * @returns recId
   */
  async addCommunityRec(
    { countryName, songTitle, artist, language, youtubeURL, genre }: {
      countryName: string;
      songTitle: string;
      artist: string;
      language: string;
      youtubeURL: string;
      genre: string;
    },
  ): Promise<{ recId: recId } | { error: string }> {
    try {
      // Ensure country exists
      const country = await this.getCountryEntry({ countryName });
      if ("error" in country) {
        return { error: country.error };
      }

      const recDocs = await this.recommendationCollection
        .find({ countryName: countryName })
        .toArray();

      // Check for exact duplicate among COMMUNITY recommendations
      const existing = recDocs.find((rec) =>
        rec.recType === "COMMUNITY" &&
        rec.songTitle.toLowerCase() === songTitle.toLowerCase() &&
        rec.artist.toLowerCase() === artist.toLowerCase() &&
        rec.language.toLowerCase() === language.toLowerCase() &&
        rec.youtubeURL.toLowerCase() === youtubeURL.toLowerCase()
      );

      if (existing) {
        return { recId: existing._id };
      }

      // Create and insert new COMMUNITY recommendation
      const newId = freshID() as recId;
      const newRec: RecommendationEntry = {
        _id: newId,
        countryName: countryName,
        songTitle,
        artist,
        language,
        youtubeURL,
        recType: "COMMUNITY",
        genre: genre || "",
      };

      await this.recommendationCollection.insertOne(newRec);
      await this.countryCollection.updateOne(
        { _id: countryName },
        { $push: { recommendations: newId } },
      );

      console.log(
        `Added new COMMUNITY recommendation ${newId} for ${countryName}.`,
      );
      return { recId: newId };
    } catch (e) {
      return { error: `Error adding community recommendation. ERROR: ${e}` };
    }
  }

  /**
   * @requires recId exists, recId.type == "COMMUNITY"
   * @effects remove recId database
   */
  async removeCommunityRec(
    { recId }: { recId: recId },
  ): Promise<void | { error: string }> {
    try {
      // 1. Lookup the recommendation by ID
      const rec = await this.recommendationCollection.findOne({ _id: recId });

      if (!rec) {
        return { error: `Recommendation ${recId} not found.` };
      }

      // 2. Ensure it's a COMMUNITY recommendation
      if (rec.recType !== "COMMUNITY") {
        return { error: `Recommendation ${recId} is not COMMUNITY type.` };
      }

      // 3. Remove the recommendation document
      await this.recommendationCollection.deleteOne({ _id: recId });

      // 4. Remove reference from the country‚Äôs recommendations list
      await this.countryCollection.updateOne(
        { _id: rec.countryName },
        { $pull: { recommendations: recId } },
      );
      console.log(
        `Removed COMMUNITY recommendation ${recId} from ${rec.countryName}.`,
      );
    } catch (e) {
      return { error: `Error removing recommendation: ${e}` };
    }
  }

  /**
   * @requires countryName exists
   * @returns counts and optional lists of recommendations for debugging/inspection
   */
  async _getCountryStatus(
    { countryName }: { countryName: string },
  ): Promise<
    | {
      country: string;
      total: number;
      systemCount: number;
      communityCount: number;
      recIds: recId[];
      systemRecs?: RecommendationEntry[];
      communityRecs?: RecommendationEntry[];
    }
    | { error: string }
  > {
    const country = await this.getCountryEntry({ countryName });
    if ("error" in country) return { error: country.error };

    try {
      // All recIds linked to this country
      const recIds = country.country.recommendations;
      if (recIds.length === 0) {
        return {
          country: countryName,
          total: 0,
          systemCount: 0,
          communityCount: 0,
          recIds: [],
        };
      }

      // Fetch all recommendation docs
      const recs = await this.recommendationCollection
        .find({ _id: { $in: recIds } })
        .toArray();

      // Categorize
      const systemRecs = recs.filter((r) => r.recType === "SYSTEM");
      const communityRecs = recs.filter((r) => r.recType === "COMMUNITY");

      return {
        country: countryName,
        total: recs.length,
        systemCount: systemRecs.length,
        communityCount: communityRecs.length,
        recIds,
        systemRecs,
        communityRecs,
      };
    } catch (e) {
      return { error: `Error inspecting database. ERROR: ${e}` };
    }
  }

  /**
   * Load configuration from .env
   */
  private loadLLM(): GeminiLLM {
    try {
      const apiKey = Deno.env.get("GEMINI_API_KEY");
      if (!apiKey) {
        throw new Error("GEMINI_API_KEY not found in environment variables.");
      }
      return new GeminiLLM(apiKey);
    } catch (error) {
      console.error(
        "‚ùå Error loading .env. Please ensure GEMINI_API_KEY is set.",
      );
      console.error("Error details:", (error as Error).message);
      Deno.exit(1);
    }
  }
}

```
